// Ê≠£Á°ÆÂØºÂÖ•ÊâÄÈúÄÊ®°Âùó
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import GUI from 'lil-gui';

// Â§ÑÁêÜÂºπÁ™óÈÄªËæë
document.addEventListener('DOMContentLoaded', () => {
    // Âª∂ËøüÁ°Æ‰øùDOMÂÆåÂÖ®Âä†ËΩΩ
    setTimeout(() => {
        // Ëé∑ÂèñÂºπÁ™óÂíåÊåâÈíÆÂÖÉÁ¥†
        const rulesModal = document.getElementById('rules-modal');
        const startBtn = document.getElementById('start-btn');
        
        // Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
        if (!rulesModal) {
            console.error('ÈîôËØØ: Êú™ÊâæÂà∞ID‰∏∫"rules-modal"ÁöÑÂºπÁ™óÂÖÉÁ¥†');
        }
        
        if (!startBtn) {
            console.error('ÈîôËØØ: Êú™ÊâæÂà∞ID‰∏∫"start-btn"ÁöÑÊåâÈíÆÂÖÉÁ¥†');
        }
        
        // ÁªëÂÆöÁÇπÂáª‰∫ã‰ª∂
        if (rulesModal && startBtn) {
            startBtn.addEventListener('click', () => {
                rulesModal.style.display = 'none';
                initGame();
            });
        }
    }, 100);
});

// Ê∏∏ÊàèÂàùÂßãÂåñÂáΩÊï∞
function initGame() {
    // ÂàùÂßãÂåñÂú∫ÊôØÊ†∏ÂøÉÁªÑ‰ª∂
    const scene = new THREE.Scene();
    const textureLoader = new THREE.TextureLoader();
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ÂàùÂßãÂåñÈÄèËßÜÁõ∏Êú∫
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // ËÆæÁΩÆÊ∏≤ÊüìÂô®
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ÁÅØÂÖâËÆæÁΩÆ
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(5, 10, 7.5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.set(2048, 2048);
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -30;
    directionalLight.shadow.camera.right = 30;
    directionalLight.shadow.camera.top = 30;
    directionalLight.shadow.camera.bottom = -30;
    scene.add(directionalLight);

    // ÊéßÂà∂Âô®ÂíåËæÖÂä©Â∑•ÂÖ∑ - Áé∞Âú®OrbitControlsÂ∫îËØ•ËÉΩÊ≠£Á°ÆÂä†ËΩΩ
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    const gui = new GUI();
    const loader = new GLTFLoader();

    // Âü∫Á°ÄÊùêË¥®
    const solidColorMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });

    // ÂÆö‰πâÊâÄÊúâÁ´ãÊñπ‰ΩìÁöÑ‰ΩçÁΩÆÔºàÊåâÈ°∫Â∫èÊéíÂàóÔºâ
    const cubePositions = [
        // Á¨¨‰∏ÄË°å (z=9)
        { x: 9, z: 9 }, { x: 7, z: 9 }, { x: 5, z: 9 }, { x: 3, z: 9 }, { x: 1, z: 9 },
        { x: -1, z: 9 }, { x: -3, z: 9 }, { x: -5, z: 9 }, { x: -7, z: 9 }, { x: -9, z: 9 },
        
        // Á¨¨‰∫åÂàó (x=-9)
        { x: -9, z: 7 }, { x: -9, z: 5 }, { x: -9, z: 3 }, { x: -9, z: 1 }, { x: -9, z: -1 },
        { x: -9, z: -3 }, { x: -9, z: -5 }, { x: -9, z: -7 }, { x: -9, z: -9 },
        
        // Á¨¨‰∏âË°å (z=-9)
        { x: -7, z: -9 }, { x: -5, z: -9 }, { x: -3, z: -9 }, { x: -1, z: -9 }, { x: 1, z: -9 },
        { x: 3, z: -9 }, { x: 5, z: -9 }, { x: 7, z: -9 }, { x: 9, z: -9 },
        
        // Á¨¨ÂõõÂàó (x=9)
        { x: 9, z: -7 }, { x: 9, z: -5 }, { x: 9, z: -3 }, { x: 9, z: -1 }, { x: 9, z: 1 },
        { x: 9, z: 3 }, { x: 9, z: 5 }, { x: 9, z: 7 }
    ];

    // ÂàõÂª∫ÊâÄÊúâÁ´ãÊñπ‰Ωì
    cubePositions.forEach((pos, index) => {
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        
        // ÂàõÂª∫ÊùêË¥®Êï∞ÁªÑÔºàÂè™ÊúâÈ°∂Èù¢‰ΩøÁî®Á∫πÁêÜÔºâ
        const materials = [
            solidColorMaterial, 
            solidColorMaterial, 
            new THREE.MeshLambertMaterial({ 
                map: textureLoader.load(`tie/${index + 1}.jpg`)
            }),
            solidColorMaterial, 
            solidColorMaterial, 
            solidColorMaterial
        ];
        
        const cube = new THREE.Mesh(geometry, materials);
        cube.position.set(pos.x, -1, pos.z);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);
    });

    // ÂÆö‰πâÊâÄÊúâÁêÉ‰ΩìÁöÑ‰ΩçÁΩÆ
    const spherePositions = [
        // Á¨¨‰∏ÄË°å (z=9)
        { x: 7, z: 9 }, { x: 5, z: 9 }, { x: 3, z: 9 }, { x: 1, z: 9 },
        { x: -1, z: 9 }, { x: -3, z: 9 },  { x: -7, z: 9 }, { x: -9, z: 9 },
        
        // Á¨¨‰∫åÂàó (x=-9)
        { x: -9, z: 7 }, { x: -9, z: 5 },  { x: -9, z: 1 }, { x: -9, z: -1 },
         { x: -9, z: -5 }, { x: -9, z: -7 }, 
        
        // Á¨¨‰∏âË°å (z=-9)
        { x: -7, z: -9 }, { x: -5, z: -9 }, { x: -3, z: -9 }, { x: -1, z: -9 }, { x: 1, z: -9 },
         { x: 5, z: -9 }, { x: 7, z: -9 }, { x: 9, z: -9 },
        
        // Á¨¨ÂõõÂàó (x=9)
        { x: 9, z: -7 }, { x: 9, z: -5 },  { x: 9, z: -1 }, { x: 9, z: 1 },
         { x: 9, z: 5 }, { x: 9, z: 7 }
    ];

    // ÂàõÂª∫ÊâÄÊúâÁêÉ‰Ωì
    spherePositions.forEach((pos) => {
        const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 16);
        const sphereMaterials = new THREE.MeshLambertMaterial({ 
            map: textureLoader.load(`tie/37.jpg`)
        });
        
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterials);
        sphere.position.set(pos.x, 0.5, pos.z);
        sphere.castShadow = true;
        scene.add(sphere);
    });

    // ÂÆö‰πâÊâÄÊúâ‰∫ã‰ª∂ÁâåÁöÑ‰ΩçÁΩÆ
    const allBoxes = []; 
    const boxPositions = [
        // Á¨¨‰∏ÄË°å (z=9)
        { x: -5, z: 9 },
        
        // Á¨¨‰∫åÂàó (x=-9)
        { x: -9, z: 3 }, { x: -9, z: -3 },  { x: -9, z: -9 },
        
        // Á¨¨‰∏âË°å (z=-9)
        { x: 3, z: -9 }, 
        
        // Á¨¨ÂõõÂàó (x=9)
        { x: 9, z: -3 }, { x: 9, z: 3 }
    ];

    // ÂàõÂª∫ÊâÄÊúâ‰∫ã‰ª∂Áâå
    boxPositions.forEach((pos) => {
        const boxGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const boxMaterials = new THREE.MeshLambertMaterial({ 
            map: textureLoader.load(`tie/38.jpg`)
        });
        
        const box = new THREE.Mesh(boxGeometry, boxMaterials);
        box.position.set(pos.x, 0.5, pos.z);
        box.castShadow = true;
        scene.add(box);
        allBoxes.push(box);
    });

    // Ê∑ªÂä†Êé∑È™∞Â≠êÊéßÂà∂
    gui.add({ Êé∑È™∞Â≠ê: () => {
        const dice = Math.floor(Math.random() * 6) + 1;
        console.log('Êé∑Âá∫:', dice);
        movePlayer(dice);
    }}, 'Êé∑È™∞Â≠ê');

    // ÂàõÂª∫Áé©ÂÆ∂Ê£ãÂ≠ê
    const base = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.7, 1.5, 32),
        new THREE.MeshLambertMaterial({ color: 0x333333 })
    );
    base.position.y = 0.5; 
    base.castShadow = true;

    const playerTop = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 32, 16),
        new THREE.MeshLambertMaterial({ color: 0xff0000 })
    );
    playerTop.position.y = 1.3;   
    playerTop.castShadow = true; 

    const player = new THREE.Group();
    player.add(base);
    player.add(playerTop);
    scene.add(player);

    // ËÆæÁΩÆÁé©ÂÆ∂ÂàùÂßã‰ΩçÁΩÆ
    const start = cubePositions[0];
    player.position.set(start.x, 0, start.z);
    let currentIndex = 0;

    // Áé©ÂÆ∂ÁßªÂä®ÂáΩÊï∞
    async function movePlayer(steps) {
        currentIndex = (currentIndex + steps) % cubePositions.length;
        const target = cubePositions[currentIndex];

        // ÁßªÂä®Âà∞ÁõÆÊ†áÊ†ºÂ≠ê
        player.position.set(target.x, 0, target.z);

        // Â§ÑÁêÜ‰º†ÈÄÅÁÇπÈÄªËæë
        const isTopLeft = target.x === -9 && target.z === 9;
        const isBottomRight = target.x === 9 && target.z === -9;

        if (isTopLeft || isBottomRight) {
            const to = isTopLeft
                ? cubePositions.find(p => p.x === 9 && p.z === -9)
                : cubePositions.find(p => p.x === -9 && p.z === 9);

            console.log('üí§ ‰º†ÈÄÅÂÄíËÆ°Êó∂...');
            await new Promise(r => setTimeout(r, 800));
            currentIndex = cubePositions.indexOf(to);
            player.position.set(to.x, 0, to.z);
            console.log('üîÆ ‰º†ÈÄÅÂÆåÊàêÔºÅ');
        }
    }

    // ËÆæÁΩÆÁêÉ‰ΩìÈ¢úËâ≤ÈÄâÊã©Âô®
    const colorPresets = {
        ‰∏çÊ≠ªÈ∏ü: '#ff0000',
        Ë¥§ËÄÖ: '#00c853',
        Êç∑È£é: '#29b6f6',
        ËäÆÂ®ú: '#7c4dff',
        Â•á‰πê: '#ffea00',
        ÊöÆËù∂: '#ff6090'
    };
    
    const pieceOptions = { ÈÖçËâ≤: '‰∏çÊ≠ªÈ∏ü' };
    const topMat = new THREE.MeshStandardMaterial({
        color: colorPresets[pieceOptions.ÈÖçËâ≤],
        metalness: 0.3,
        roughness: 0.4
    });
    playerTop.material = topMat;
    
    gui.add(pieceOptions, 'ÈÖçËâ≤', Object.keys(colorPresets))
       .name('ÁêÉ‰ΩìÈ¢úËâ≤')
       .onChange((key) => {
           topMat.color.set(colorPresets[key]);
       });

    // ÂàõÂª∫Á¥¢ÈÅì
    const zhuzi1 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 5),
        new THREE.MeshLambertMaterial({ color: '#444945' })
    );
    zhuzi1.position.set(-8, 0.5, 8);
    zhuzi1.castShadow = true;
    scene.add(zhuzi1);

    const zhuzi2 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 5),
        new THREE.MeshLambertMaterial({ color: '#444945' })
    );
    zhuzi2.position.set(8, 0.5, -8);
    zhuzi2.castShadow = true;
    scene.add(zhuzi2);

    const shengzi = new THREE.Mesh(
        new THREE.CylinderGeometry(0.01, 0.01, 22.7),
        new THREE.MeshLambertMaterial({ color: '#e2d73a' })
    );
    shengzi.rotation.x = -Math.PI / 2;
    shengzi.rotation.z = -Math.PI / 4;
    shengzi.position.set(0, 2.5, 0);
    shengzi.castShadow = true;
    scene.add(shengzi);

    // ÂàõÂª∫Âú∞Èù¢
    const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40),
        new THREE.MeshLambertMaterial({ 
            map: textureLoader.load(`tie/39.jpg`) 
        })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -2;
    plane.receiveShadow = true;
    scene.add(plane);

    // Âä†ËΩΩÊ®°Âûã1
    let mixer;
    loader.load(
        'models1/scene.gltf',
        (gltf) => {
            console.log('Ê®°Âûã1Âä†ËΩΩÊàêÂäü!');
            const model = gltf.scene;
            model.scale.set(3, 3, 3);
            model.position.set(-2, -2, -2);
            model.rotation.y = -Math.PI / 2;
            model.traverse((child) => {
                if (child.isMesh) {
                    child.receiveShadow = true;
                    child.castShadow = true;
                }
            });
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
                const action = mixer.clipAction(clip);
                action.play();
            });
            scene.add(model);
        },
        undefined,
        (error) => {
            console.error('Ê®°Âûã1Âä†ËΩΩÂ§±Ë¥•:', error);
        }
    );

    // Âä†ËΩΩÊ®°Âûã2
    let mixer2;
    loader.load(
        'models2/scene.gltf',
        (gltf) => {
            console.log('Ê®°Âûã2Âä†ËΩΩÊàêÂäü!');
            const model = gltf.scene;
            model.scale.set(0.02, 0.02, 0.02);
            model.position.set(-3, -2, 7);
            model.traverse((child) => {
                if (child.isMesh) {
                    child.receiveShadow = true;
                    child.castShadow = true;
                }
            });
            mixer2 = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
                const action = mixer2.clipAction(clip);
                action.play();
            });
            scene.add(model);
        },
        undefined,
        (error) => {
            console.error('Ê®°Âûã2Âä†ËΩΩÂ§±Ë¥•:', error);
        }
    );

    // ËÆæÁΩÆÁõ∏Êú∫‰ΩçÁΩÆ
    camera.position.set(0, 15, 20);
    camera.lookAt(0, 0, 0);

    // Â§ÑÁêÜÁ™óÂè£Â§ßÂ∞èÂèòÂåñ
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Â§ÑÁêÜÈº†Ê†áÁßªÂä®‰∫ã‰ª∂
    window.addEventListener('mousemove', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // Âä®ÁîªÂæ™ÁéØ
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        // ÊóãËΩ¨ÊâÄÊúâ‰∫ã‰ª∂Áâå
        allBoxes.forEach(box => {
            box.rotation.x += 0.01;
            box.rotation.y += 0.01;
        });
        
        // Êõ¥Êñ∞Âä®ÁîªÊ∑∑ÂêàÂô®
        if (mixer) mixer.update(delta);
        if (mixer2) mixer2.update(delta);
        
        controls.update();
        renderer.render(scene, camera);
    }

    // ÂêØÂä®Âä®ÁîªÂæ™ÁéØ
    animate();
}
    